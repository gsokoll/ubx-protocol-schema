{
  "message_name": "UBX-ESF-MEAS",
  "num_extractions": 13,
  "adjudication": {
    "canonical_structure": {
      "name": "UBX-ESF-MEAS",
      "class_id": "0x10",
      "message_id": "0x02",
      "description": "External sensor fusion measurements",
      "payload": {
        "length": {
          "variable": {
            "base": 8,
            "formula": "8 + (numMeas * 4) + (calibTtagValid ? 4 : 0)"
          }
        },
        "fields": [
          {
            "name": "timeTag",
            "byte_offset": 0,
            "data_type": "U4",
            "description": "Time tag of measurement generated by external sensor",
            "unit": "ms"
          },
          {
            "name": "flags",
            "byte_offset": 4,
            "data_type": "X2",
            "bitfield": {
              "bits": [
                {
                  "name": "timeMarkSent",
                  "bit_start": 0,
                  "bit_end": 1
                },
                {
                  "name": "timeMarkEdge",
                  "bit_start": 2,
                  "bit_end": 2
                },
                {
                  "name": "calibTtagValid",
                  "bit_start": 3,
                  "bit_end": 3,
                  "description": "1 if calibration time tag is present, 0 otherwise"
                },
                {
                  "name": "numMeas",
                  "bit_start": 11,
                  "bit_end": 15,
                  "description": "Number of measurements"
                }
              ]
            }
          },
          {
            "name": "id",
            "byte_offset": 6,
            "data_type": "U2",
            "description": "Identification number of data provider"
          }
        ],
        "repeated_groups": [
          {
            "name": "measurements",
            "repetition_type": "count_field",
            "count_field": "flags.numMeas",
            "group_size_bytes": 4,
            "base_offset": 8,
            "fields": [
              {
                "name": "data",
                "byte_offset": 0,
                "data_type": "X4",
                "bitfield": {
                  "bits": [
                    {
                      "name": "dataField",
                      "bit_start": 0,
                      "bit_end": 23,
                      "data_type": "U4"
                    },
                    {
                      "name": "dataType",
                      "bit_start": 24,
                      "bit_end": 29,
                      "data_type": "U1"
                    }
                  ]
                }
              }
            ]
          }
        ],
        "optional_groups": [
          {
            "name": "calibrated_time_tag",
            "condition": "flags.calibTtagValid == 1",
            "base_offset_formula": "8 + (flags.numMeas * 4)",
            "fields": [
              {
                "name": "calibTtag",
                "byte_offset": 0,
                "data_type": "U4",
                "description": "Receiver local time calibrated",
                "unit": "ms"
              }
            ]
          }
        ]
      }
    },
    "canonical_confidence": "high",
    "extraction_verdicts": [
      {
        "source": "u-blox-F9-LAP-1.50_InterfaceDescription_UBXDOC-963802114-13052",
        "verdict": "extraction_error",
        "issues": [
          "Inconsistent JSON: Length formula accounts for optional 4 bytes, but the 'calibTtag' field is missing from the fields list."
        ]
      },
      {
        "source": "F9-HPS-1.21_InterfaceDescription_UBX-21019746",
        "verdict": "extraction_error",
        "issues": [
          "Inconsistent JSON: Length formula accounts for optional 4 bytes, but the 'calibTtag' field is missing from the fields list."
        ]
      },
      {
        "source": "u-blox-F9-LAP-1.30_InterfaceDescription_UBX-22005157",
        "verdict": "extraction_error",
        "issues": [
          "Contradiction: Description states 'calibTtag' is present if flag set, but length formula and fields list omit it completely."
        ]
      },
      {
        "source": "M9-ADR-5.15_InterfaceDescription_UBX-22037101",
        "verdict": "correct",
        "issues": []
      },
      {
        "source": "F9-HPS120_Interfacedescription_UBX-19056845",
        "verdict": "valid_variation",
        "issues": [
          "Legacy/Simplified definition: 'calibTtagValid' is 'Always set to zero', and extraction consistently omits the optional field."
        ]
      },
      {
        "source": "u-blox-M9-MDR-2.16_InterfaceDescription_UBX-22037308",
        "verdict": "correct",
        "issues": []
      },
      {
        "source": "u-blox-F9-DBD-1.30_InterfaceDescription_UBX-23006360",
        "verdict": "correct",
        "issues": []
      },
      {
        "source": "M9-ADR-5.10_InterfaceDescription_UBX-20048972_C1-Public",
        "verdict": "extraction_error",
        "issues": [
          "Inconsistent JSON: Length formula includes optional calibTtag logic, but the field is missing from the structure."
        ]
      },
      {
        "source": "M9-MDR-2.10_InterfaceDescription_UBX-21036678",
        "verdict": "extraction_error",
        "issues": [
          "Logic Error: 'calibTtag' defined at fixed offset 8 (overlapping with measurements).",
          "Logic Error: 'optional_if' condition checks for valid == 0 instead of 1."
        ]
      },
      {
        "source": "LAP120_Interfacedescription_UBX-20046191",
        "verdict": "valid_variation",
        "issues": [
          "Legacy/Simplified definition: 'calibTtagValid' is 'Always set to zero', and extraction consistently omits the optional field."
        ]
      },
      {
        "source": "u-blox8-M8_ReceiverDescrProtSpec_UBX-13003221",
        "verdict": "extraction_error",
        "issues": [
          "Bitfield Error: Defines 'dataType' as bits 0-5 and 'dataField' as 6-29. Canonical UBX standard is 'dataField' 0-23 and 'dataType' 24-29."
        ]
      },
      {
        "source": "u-blox-F9-HPS-1.40_InterfaceDescription_UBXDOC-963802114-13138",
        "verdict": "extraction_error",
        "issues": [
          "Inconsistent JSON: Length formula implies optional field logic, but 'calibTtag' field definition is missing."
        ]
      },
      {
        "source": "u-blox-F9-HPS-1.30_InterfaceDescription_UBX-22010984",
        "verdict": "correct",
        "issues": []
      }
    ],
    "valid_variations": [
      {
        "sources": [
          "M9-ADR-5.15_InterfaceDescription_UBX-22037101",
          "u-blox-M9-MDR-2.16_InterfaceDescription_UBX-22037308",
          "u-blox-F9-DBD-1.30_InterfaceDescription_UBX-23006360",
          "u-blox-F9-HPS-1.30_InterfaceDescription_UBX-22010984"
        ],
        "structure": {
          "description": "Full Protocol: Includes optional 'calibTtag' (4 bytes) at the end if flag bit 3 is set."
        },
        "reason": "These manuals explicitly describe and define the optional calibration time tag field and the logic for its inclusion."
      },
      {
        "sources": [
          "F9-HPS120_Interfacedescription_UBX-19056845",
          "LAP120_Interfacedescription_UBX-20046191"
        ],
        "structure": {
          "description": "Restricted Protocol: 'calibTtag' is omitted."
        },
        "reason": "In these specific interface descriptions, the 'calibTtagValid' flag is marked as 'Always set to zero', effectively removing the optional field from the message payload in that firmware version."
      }
    ],
    "reasoning": "The core message structure is consistent across all versions: Header (8 bytes) + Repeated Measurements (N*4 bytes). The primary variation is the support for the optional 'calibrated time tag' (4 bytes) appended at the end. Some manuals (M9/F9 generations) support this, signaled by bit 3 in flags. Others (older or Lite versions) mandate bit 3 be zero, effectively excluding the field. \n\nSeveral extractions correctly identify the existence of the optional field in their description or length formula but fail to include the field definition in the JSON structure (Extractions 1, 2, 8, 12). Extraction 11 contains a significant error in the bitfield definition (reversing data and type bits). Extraction 9 has critical errors in field offsets. Extractions 4, 6, 7, and 13 are the most accurate representations of the full protocol."
  }
}